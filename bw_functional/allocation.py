from functools import partial
from typing import Callable, List
from logging import getLogger

from .node_classes import Process, Function

log = getLogger(__name__)


def remove_output(d: dict) -> dict:
    if "output" in d:
        del d["output"]
    return d


def generic_allocation(
    process: Process,
    getter: lambda function: float(),
) -> List[dict]:
    """Allocation by single allocation factor generated by `func`.

    Allocation amount is edge amount times function(edge_data, act) divided by sum of all edge
    amounts times function(edge_data, act).

    **No longer** skips functional edges with zero allocation values."""
    if not isinstance(process, Process):
        raise ValueError("Activity must be a Process instance")

    if not process.multifunctional:
        return []

    functions = []
    for fn in process.functions():
        if fn.get("substitution_factor", 0) > 0 and fn["allocation_factor"] > 0:
            fn["allocation_factor"] = 0.0
            fn.save()
        elif fn.get("substitution_factor", 0) <= 0:
            functions.append(fn)

    total = sum([getter(function) for function in functions])

    if not total:
        raise ZeroDivisionError("Sum of allocation factors is zero")

    for i, function in enumerate(functions):
        factor = getter(function) / total
        function["allocation_factor"] = factor
        function.save()


def get_property_value(
    function: Function,
    property_label: str,
) -> float:
    if not isinstance(function, Function):
        raise ValueError("Passed non-function for allocation")

    props = function.get("properties")

    if not props:
        raise KeyError(f"Function {function} from process {function.processor} doesn't have properties")

    prop = props.get(property_label)

    if not prop:
        raise KeyError(f"Function {function} from {function.processor} missing property {property_label}")

    if isinstance(prop, float):
        log.warning("Property using legacy float format")
        return prop

    if prop.get("normalize", False):
        return function.processing_edge["amount"] * prop["amount"]
    else:
        return prop["amount"]


def property_allocation(property_label: str) -> Callable:
    getter = partial(get_property_value, property_label=property_label)
    return partial(generic_allocation, getter=getter)


allocation_strategies = {
    "equal": partial(generic_allocation, getter=lambda x: 1.0),
    "manual": partial(generic_allocation, getter=lambda x: x.get("allocation_factor", 1)),
}
