from copy import deepcopy
from functools import partial
from typing import Callable, List, Optional, Union
from uuid import uuid4

from bw2data import get_node
from bw2data.backends.proxies import Activity
from bw2data.errors import UnknownObject
from bw2io.utils import rescale_exchange
from loguru import logger


def generic_allocation(
    act: Union[dict, Activity],
    func: Callable,
    strategy_label: Optional[str] = None,
) -> List[dict]:
    """Allocation by single allocation factor generated by `func`.

    Allocation amount is edge amount times function(edge_data, act) divided by sum of all edge
    amounts times function(edge_data, act).

    Skips functional edges with zero allocation values."""
    if isinstance(act, Activity):
        act_data = act._data
        act_data["exchanges"] = [exc._data for exc in act.exchanges()]
        act = act_data

    if act.get("type") == "readonly_process":
        return []
    elif sum(1 for exc in act.get("exchanges", []) if exc.get("functional")) < 2:
        return []

    total = 0
    for exc in filter(lambda x: x.get("functional"), act.get("exchanges", [])):
        total += func(exc, act)

    if not total:
        raise ZeroDivisionError("Sum of allocation factors is zero")

    processes = [act]

    for exc in filter(lambda x: x.get("functional"), act.get("exchanges", [])):
        factor = func(exc, act) / total
        if not factor:
            continue

        logger.debug(
            "Using allocation factor {f} for functional edge {e} on activity {a}",
            f=factor,
            e=repr(exc),
            a=repr(act),
        )

        # Added by `add_exchange_input_if_missing`, but shouldn't be used
        if exc.get("mf_artificial_code"):
            del exc["input"]
            del exc["mf_artificial_code"]

        # We need to allow for both initial allocation, and also re-allocation
        # We also need to generate codes for processes linked to products with existing codes
        if exc.get("mf_allocated"):
            # Don't need to think, made choice on initial allocation
            process_code = exc["mf_allocated_process_code"]
        elif exc.get("input"):
            # Initial allocation with link to a known node but separate process
            exc["mf_allocated"] = True
            process_code = exc["mf_allocated_process_code"] = uuid4().hex
        else:
            # Create new process+product node with same generated code
            # either desired or random
            exc["mf_allocated"] = True
            process_code = exc["mf_allocated_process_code"] = exc.get("desired_code") or uuid4().hex
            exc["input"] = (act["database"], process_code)
            logger.debug(
                "Creating new product code {c} for functional edge:\n{e}\nOn activity\n{a}",
                c=process_code,
                e=repr(exc),
                a=repr(act),
            )

        try:
            product = get_node(database=exc["input"][0], code=exc["input"][1])
        except UnknownObject:
            # Try using attributes stored on the edge
            # Might not work, but better than trying to give access to whole raw database
            # currently being written
            product = exc

        allocated_process = deepcopy(act)
        if "id" in allocated_process:
            del allocated_process["id"]
        if strategy_label:
            allocated_process["mf_strategy_label"] = strategy_label
        allocated_process["code"] = process_code
        allocated_process["mf_parent_key"] = (act["database"], act["code"])
        allocated_process["type"] = "readonly_process"
        allocated_process["reference product"] = product.get("reference product") or product.get(
            "name", "(unspecified)"
        )
        allocated_process["unit"] = product.get("unit", "(unspecified)")

        new_functional_exchange = deepcopy(exc)
        allocated_process["exchanges"] = [new_functional_exchange]

        for other in filter(lambda x: not x.get("functional"), act["exchanges"]):
            allocated_process["exchanges"].append(rescale_exchange(deepcopy(other), factor))

        processes.append(allocated_process)

    return processes


def get_allocation_factor_from_property(edge_data: dict, node: dict, property_label: str) -> float:
    if "properties" not in edge_data:
        raise KeyError(
            f"Edge {edge_data} from process {node.get('name')} (id {node.get('id')}) doesn't have properties"
        )
    try:
        return edge_data["amount"] * edge_data["properties"][property_label]
    except KeyError as err:
        raise KeyError(
            f"Edge {edge_data} from process {node.get('name')} (id {node.get('id')}) missing property {property_label}"
        ) from err


def property_allocation(property_label: str) -> Callable:
    return partial(
        generic_allocation,
        func=partial(get_allocation_factor_from_property, property_label=property_label),
        strategy_label=f"property allocation by '{property_label}'",
    )


allocation_strategies = {
    "price": property_allocation("price"),
    "manual": property_allocation("manual"),
    "mass": property_allocation("mass"),
    "equal": partial(generic_allocation, func=lambda x, y: 1.0),
}
